{"ast":null,"code":"import { createFactory as t, $eq as r, $ne as i, $lt as n, $lte as e, $gt as u, $gte as o, $in as s, $nin as f, $all as a, $size as c, $regex as h, $options as v, $elemMatch as l, $exists as d, eq as b, ne as y, lt as p, lte as w, gt as g, gte as E, within as A, nin as $, all as j, size as m, regex as M, elemMatch as x, exists as O, and as F } from \"@ucast/mongo2js\";\n\nfunction _(t, r) {\n  for (var i = 0; i < r.length; i++) {\n    var n = r[i];\n    n.enumerable = n.enumerable || false;\n    n.configurable = true;\n    if (\"value\" in n) n.writable = true;\n    Object.defineProperty(t, n.key, n);\n  }\n}\n\nfunction P(t, r, i) {\n  if (r) _(t.prototype, r);\n  if (i) _(t, i);\n  return t;\n}\n\nfunction R() {\n  R = Object.assign || function (t) {\n    for (var r = 1; r < arguments.length; r++) {\n      var i = arguments[r];\n\n      for (var n in i) if (Object.prototype.hasOwnProperty.call(i, n)) t[n] = i[n];\n    }\n\n    return t;\n  };\n\n  return R.apply(this, arguments);\n}\n\nfunction k(t, r) {\n  t.prototype = Object.create(r.prototype);\n  t.prototype.constructor = t;\n  B(t, r);\n}\n\nfunction B(t, r) {\n  B = Object.setPrototypeOf || function t(r, i) {\n    r.__proto__ = i;\n    return r;\n  };\n\n  return B(t, r);\n}\n\nfunction C(t) {\n  if (void 0 === t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return t;\n}\n\nfunction T(t) {\n  return Array.isArray(t) ? t : [t];\n}\n\nvar q = \"__caslSubjectType__\";\n\nfunction z(t, r) {\n  if (r) if (!r.hasOwnProperty(q)) Object.defineProperty(r, q, {\n    value: t\n  });else if (t !== r[q]) throw new Error(\"Trying to cast object to subject type \" + t + \" but previously it was casted to \" + r[q]);\n  return r;\n}\n\nvar S = function t(r) {\n  var i = typeof r;\n  return \"string\" === i || \"function\" === i;\n};\n\nvar Y = function t(r) {\n  return r.modelName || r.name;\n};\n\nvar D = function t(r) {\n  return \"string\" === typeof r ? r : Y(r);\n};\n\nfunction L(t) {\n  if (t.hasOwnProperty(q)) return t[q];\n  return Y(t.constructor);\n}\n\nfunction G(t, r, i) {\n  var n = T(r);\n  var e = 0;\n\n  while (e < n.length) {\n    var u = n[e++];\n    if (t.hasOwnProperty(u)) n = i(n, t[u]);\n  }\n\n  return n;\n}\n\nfunction H(t, r) {\n  if (\"string\" === typeof r && -1 !== t.indexOf(r)) return r;\n\n  for (var i = 0; i < r.length; i++) if (-1 !== t.indexOf(r[i])) return r[i];\n\n  return null;\n}\n\nvar I = function t(r, i) {\n  return r.concat(i);\n};\n\nfunction J(t, r) {\n  if (r in t) throw new Error('Cannot use \"' + r + \"\\\" as an alias because it's reserved action.\");\n  var i = Object.keys(t);\n\n  var n = function t(i, n) {\n    var e = H(i, n);\n    if (e) throw new Error(\"Detected cycle \" + e + \" -> \" + i.join(\", \"));\n    var u = \"string\" === typeof n && n === r || -1 !== i.indexOf(r) || Array.isArray(n) && -1 !== n.indexOf(r);\n    if (u) throw new Error('Cannot make an alias to \"' + r + '\" because this is reserved action');\n    return i.concat(n);\n  };\n\n  for (var e = 0; e < i.length; e++) G(t, i[e], n);\n}\n\nfunction K(t, r) {\n  if (!r || false !== r.skipValidate) J(t, r && r.anyAction || \"manage\");\n  return function (r) {\n    return G(t, r, I);\n  };\n}\n\nfunction N(t, r, i) {\n  for (var n = i; n < r.length; n++) t.push(r[n]);\n}\n\nfunction Q(t, r) {\n  if (!t || !t.length) return r || [];\n  if (!r || !r.length) return t || [];\n  var i = 0;\n  var n = 0;\n  var e = [];\n\n  while (i < t.length && n < r.length) if (t[i].priority < r[n].priority) {\n    e.push(t[i]);\n    i++;\n  } else {\n    e.push(r[n]);\n    n++;\n  }\n\n  N(e, t, i);\n  N(e, r, n);\n  return e;\n}\n\nfunction U(t, r, i) {\n  var n = t.get(r);\n\n  if (!n) {\n    n = i();\n    t.set(r, n);\n  }\n\n  return n;\n}\n\nvar V = function t(r) {\n  return r;\n};\n\nfunction W(t, r) {\n  if (Array.isArray(t.fields) && !t.fields.length) throw new Error(\"`rawRule.fields` cannot be an empty array. https://bit.ly/390miLa\");\n  if (t.fields && !r.fieldMatcher) throw new Error('You need to pass \"fieldMatcher\" option in order to restrict access by fields');\n  if (t.conditions && !r.conditionsMatcher) throw new Error('You need to pass \"conditionsMatcher\" option in order to restrict access by conditions');\n}\n\nvar X = function () {\n  function t(t, r, i) {\n    if (void 0 === i) i = 0;\n    W(t, r);\n    this.action = r.resolveAction(t.action);\n    this.subject = t.subject;\n    this.inverted = !!t.inverted;\n    this.conditions = t.conditions;\n    this.reason = t.reason;\n    this.fields = t.fields ? T(t.fields) : void 0;\n    this.priority = i;\n    this.t = r;\n  }\n\n  var r = t.prototype;\n\n  r.i = function t() {\n    if (this.conditions && !this.u) this.u = this.t.conditionsMatcher(this.conditions);\n    return this.u;\n  };\n\n  r.matchesConditions = function t(r) {\n    if (!this.conditions) return true;\n    if (!r || S(r)) return !this.inverted;\n    var i = this.i();\n    return i(r);\n  };\n\n  r.matchesField = function t(r) {\n    if (!this.fields) return true;\n    if (!r) return !this.inverted;\n    if (this.fields && !this.o) this.o = this.t.fieldMatcher(this.fields);\n    return this.o(r);\n  };\n\n  P(t, [{\n    key: \"ast\",\n    get: function t() {\n      var r = this.i();\n      return r ? r.ast : void 0;\n    }\n  }]);\n  return t;\n}();\n\nfunction Z(t, r) {\n  var i = {\n    value: t,\n    prev: r,\n    next: null\n  };\n  if (r) r.next = i;\n  return i;\n}\n\nfunction tt(t) {\n  if (t.next) t.next.prev = t.prev;\n  if (t.prev) t.prev.next = t.next;\n  t.next = t.prev = null;\n}\n\nvar rt = function t(r) {\n  return {\n    value: r.value,\n    prev: r.prev,\n    next: r.next\n  };\n};\n\nvar it = function t() {\n  return {\n    rules: [],\n    merged: false\n  };\n};\n\nvar nt = function t() {\n  return new Map();\n};\n\nvar et = function t(r, i) {\n  if (!r.h && i.fields) r.h = true;\n};\n\nvar ut = function () {\n  function t(t, r) {\n    if (void 0 === t) t = [];\n    if (void 0 === r) r = {};\n    this.h = false;\n    this.v = new Map();\n    this.l = {\n      conditionsMatcher: r.conditionsMatcher,\n      fieldMatcher: r.fieldMatcher,\n      resolveAction: r.resolveAction || V\n    };\n    this.p = r.anyAction || \"manage\";\n    this.g = r.anySubjectType || \"all\";\n    this.A = r.detectSubjectType || L;\n    this.$ = t;\n    this.j = this.m(t);\n  }\n\n  var r = t.prototype;\n\n  r.detectSubjectType = function t(r) {\n    if (S(r)) return r;\n    if (!r) return this.g;\n    return this.A(r);\n  };\n\n  r.update = function t(r) {\n    var i = {\n      rules: r,\n      ability: this,\n      target: this\n    };\n    this.M(\"update\", i);\n    this.$ = r;\n    this.j = this.m(r);\n    this.M(\"updated\", i);\n    return this;\n  };\n\n  r.m = function t(r) {\n    var i = new Map();\n\n    for (var n = r.length - 1; n >= 0; n--) {\n      var e = r.length - n - 1;\n      var u = new X(r[n], this.l, e);\n      var o = T(u.action);\n      var s = T(u.subject || this.g);\n      et(this, u);\n\n      for (var f = 0; f < s.length; f++) {\n        var a = U(i, s[f], nt);\n\n        for (var c = 0; c < o.length; c++) U(a, o[c], it).rules.push(u);\n      }\n    }\n\n    return i;\n  };\n\n  r.possibleRulesFor = function t(r, i) {\n    if (void 0 === i) i = this.g;\n    if (!S(i)) throw new Error('\"possibleRulesFor\" accepts only subject types (i.e., string or class) as the 2nd parameter');\n    var n = U(this.j, i, nt);\n    var e = U(n, r, it);\n    if (e.merged) return e.rules;\n    var u = r !== this.p && n.has(this.p) ? n.get(this.p).rules : void 0;\n    var o = Q(e.rules, u);\n    if (i !== this.g) o = Q(o, this.possibleRulesFor(r, this.g));\n    e.rules = o;\n    e.merged = true;\n    return o;\n  };\n\n  r.rulesFor = function t(r, i, n) {\n    var e = this.possibleRulesFor(r, i);\n    if (n && \"string\" !== typeof n) throw new Error(\"The 3rd, `field` parameter is expected to be a string. See https://stalniy.github.io/casl/en/api/casl-ability#can-of-pure-ability for details\");\n    if (!this.h) return e;\n    return e.filter(function (t) {\n      return t.matchesField(n);\n    });\n  };\n\n  r.on = function t(r, i) {\n    var n = this;\n    var e = this.v.get(r) || null;\n    var u = Z(i, e);\n    this.v.set(r, u);\n    return function () {\n      var t = n.v.get(r);\n      if (!u.next && !u.prev && t === u) n.v.delete(r);else if (u === t) n.v.set(r, u.prev);\n      tt(u);\n    };\n  };\n\n  r.M = function t(r, i) {\n    var n = this.v.get(r) || null;\n\n    while (null !== n) {\n      var e = n.prev ? rt(n.prev) : null;\n      n.value(i);\n      n = e;\n    }\n  };\n\n  P(t, [{\n    key: \"rules\",\n    get: function t() {\n      return this.$;\n    }\n  }]);\n  return t;\n}();\n\nvar ot = function (t) {\n  k(PureAbility, t);\n\n  function PureAbility() {\n    return t.apply(this, arguments) || this;\n  }\n\n  var r = PureAbility.prototype;\n\n  r.can = function t() {\n    var r = this.relevantRuleFor.apply(this, arguments);\n    return !!r && !r.inverted;\n  };\n\n  r.relevantRuleFor = function t(r, i, n) {\n    var e = this.detectSubjectType(i);\n    var u = this.rulesFor(r, e, n);\n\n    for (var o = 0, s = u.length; o < s; o++) if (u[o].matchesConditions(i)) return u[o];\n\n    return null;\n  };\n\n  r.cannot = function t() {\n    return !this.can.apply(this, arguments);\n  };\n\n  return PureAbility;\n}(ut);\n\nvar st = {\n  $eq: r,\n  $ne: i,\n  $lt: n,\n  $lte: e,\n  $gt: u,\n  $gte: o,\n  $in: s,\n  $nin: f,\n  $all: a,\n  $size: c,\n  $regex: h,\n  $options: v,\n  $elemMatch: l,\n  $exists: d\n};\nvar ft = {\n  eq: b,\n  ne: y,\n  lt: p,\n  lte: w,\n  gt: g,\n  gte: E,\n  in: A,\n  nin: $,\n  all: j,\n  size: m,\n  regex: M,\n  elemMatch: x,\n  exists: O,\n  and: F\n};\n\nvar at = function r(i, n, e) {\n  return t(R({}, st, i), R({}, ft, n), e);\n};\n\nvar ct = t(st, ft);\nvar ht = /[-/\\\\^$+?.()|[\\]{}]/g;\nvar vt = /\\.?\\*+\\.?/g;\nvar lt = /\\*+/;\nvar dt = /\\./g;\n\nfunction bt(t, r, i) {\n  var n = \"*\" === i[0] || \".\" === t[0] && \".\" === t[t.length - 1] ? \"+\" : \"*\";\n  var e = -1 === t.indexOf(\"**\") ? \"[^.]\" : \".\";\n  var u = t.replace(dt, \"\\\\$&\").replace(lt, e + n);\n  return r + t.length === i.length ? \"(?:\" + u + \")?\" : u;\n}\n\nfunction yt(t, r, i) {\n  if (\".\" === t && (\"*\" === i[r - 1] || \"*\" === i[r + 1])) return t;\n  return \"\\\\\" + t;\n}\n\nfunction pt(t) {\n  var r = t.map(function (t) {\n    return t.replace(ht, yt).replace(vt, bt);\n  });\n  var i = r.length > 1 ? \"(?:\" + r.join(\"|\") + \")\" : r[0];\n  return new RegExp(\"^\" + i + \"$\");\n}\n\nvar wt = function t(r) {\n  var i;\n  return function (t) {\n    if (\"undefined\" === typeof i) i = r.every(function (t) {\n      return -1 === t.indexOf(\"*\");\n    }) ? null : pt(r);\n    return null === i ? -1 !== r.indexOf(t) : i.test(t);\n  };\n};\n\nvar gt = function (t) {\n  k(Ability, t);\n\n  function Ability(r, i) {\n    if (void 0 === r) r = [];\n    if (void 0 === i) i = {};\n    return t.call(this, r, R({\n      conditionsMatcher: ct,\n      fieldMatcher: wt\n    }, i)) || this;\n  }\n\n  return Ability;\n}(ot);\n\nvar Et = function () {\n  function t(t) {\n    this.O = t;\n  }\n\n  var r = t.prototype;\n\n  r.because = function t(r) {\n    this.O.reason = r;\n    return this;\n  };\n\n  return t;\n}();\n\nvar At = function () {\n  function AbilityBuilder(t) {\n    this.rules = [];\n    this.F = t;\n    this.can = this.can.bind(this);\n    this.cannot = this.cannot.bind(this);\n    this.build = this.build.bind(this);\n  }\n\n  var t = AbilityBuilder.prototype;\n\n  t.can = function t(r, i, n, e) {\n    var u = {\n      action: r\n    };\n\n    if (i) {\n      u.subject = i;\n      if (Array.isArray(n) || \"string\" === typeof n) u.fields = n;else if (\"undefined\" !== typeof n) u.conditions = n;\n      if (\"undefined\" !== typeof e) u.conditions = e;\n    }\n\n    this.rules.push(u);\n    return new Et(u);\n  };\n\n  t.cannot = function t(r, i, n, e) {\n    var u = this.can(r, i, n, e);\n    u.O.inverted = true;\n    return u;\n  };\n\n  t.build = function t(r) {\n    return new this.F(this.rules, r);\n  };\n\n  return AbilityBuilder;\n}();\n\nfunction defineAbility(t, r) {\n  var i = new At(gt);\n  var n = t(i.can, i.cannot);\n  if (n && \"function\" === typeof n.then) return n.then(function () {\n    return i.build(r);\n  });\n  return i.build(r);\n}\n\nvar $t = function t(r) {\n  return 'Cannot execute \"' + r.action + '\" on \"' + r.subjectType + '\"';\n};\n\nvar jt = function t(r) {\n  this.message = r;\n};\n\njt.prototype = Object.create(Error.prototype);\n\nvar mt = function (t) {\n  k(ForbiddenError, t);\n\n  ForbiddenError.setDefaultMessage = function t(r) {\n    this._ = \"string\" === typeof r ? function () {\n      return r;\n    } : r;\n  };\n\n  ForbiddenError.from = function t(r) {\n    return new this(r);\n  };\n\n  function ForbiddenError(r) {\n    var i;\n    i = t.call(this, \"\") || this;\n    i.ability = r;\n\n    if (\"function\" === typeof Error.captureStackTrace) {\n      i.name = \"ForbiddenError\";\n      Error.captureStackTrace(C(i), i.constructor);\n    }\n\n    return i;\n  }\n\n  var r = ForbiddenError.prototype;\n\n  r.setMessage = function t(r) {\n    this.message = r;\n    return this;\n  };\n\n  r.throwUnlessCan = function t() {\n    var r;\n    var i = (r = this.ability).relevantRuleFor.apply(r, arguments);\n    if (i && !i.inverted) return;\n    this.action = arguments.length <= 0 ? void 0 : arguments[0];\n    this.subject = arguments.length <= 1 ? void 0 : arguments[1];\n    this.subjectType = D(this.ability.detectSubjectType(arguments.length <= 1 ? void 0 : arguments[1]));\n    this.field = arguments.length <= 2 ? void 0 : arguments[2];\n    var n = i ? i.reason : \"\";\n    this.message = this.message || n || this.constructor._(this);\n    throw this;\n  };\n\n  return ForbiddenError;\n}(jt);\n\nmt._ = $t;\nvar Mt = Object.freeze({\n  __proto__: null\n});\nexport { gt as Ability, At as AbilityBuilder, mt as ForbiddenError, ot as PureAbility, at as buildMongoQueryMatcher, K as createAliasResolver, defineAbility, L as detectSubjectType, wt as fieldPatternMatcher, $t as getDefaultErrorMessage, Mt as hkt, ct as mongoQueryMatcher, z as subject, T as wrapArray };","map":null,"metadata":{},"sourceType":"module"}