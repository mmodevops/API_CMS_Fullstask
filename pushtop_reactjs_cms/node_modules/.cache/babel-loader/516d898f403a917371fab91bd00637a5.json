{"ast":null,"code":"import { optimizedCompoundCondition as e, FieldCondition as t, CompoundCondition as r, ITSELF as n, NULL_CONDITION as o, buildAnd as a, ObjectQueryParser as i } from \"@ucast/core\";\nexport { defaultInstructionParsers as defaultParsers } from \"@ucast/core\";\n\nfunction f(e, t) {\n  if (!Array.isArray(t)) throw new Error('\"' + e.name + '\" expects value to be an array');\n}\n\nfunction u(e, t) {\n  if (f(e, t), !t.length) throw new Error('\"' + e.name + '\" expects to have at least one element in array');\n}\n\nvar c = function (e) {\n  return function (t, r) {\n    if (typeof r !== e) throw new Error('\"' + t.name + '\" expects value to be a \"' + e + '\"');\n  };\n},\n    p = {\n  type: \"compound\",\n  validate: u,\n  parse: function (t, r, n) {\n    var o = n.parse,\n        a = r.map(function (e) {\n      return o(e);\n    });\n    return e(t.name, a);\n  }\n},\n    s = p,\n    l = {\n  type: \"compound\",\n  validate: u\n},\n    d = {\n  type: \"field\",\n  validate: function (e, t) {\n    if (!(t && (t instanceof RegExp || t.constructor === Object))) throw new Error('\"' + e.name + '\" expects to receive either regular expression or object of field operators');\n  },\n  parse: function (e, n, o) {\n    var a = n instanceof RegExp ? new t(\"regex\", o.field, n) : o.parse(n, o);\n    return new r(e.name, [a]);\n  }\n},\n    v = {\n  type: \"field\",\n  validate: function (e, t) {\n    if (!t || t.constructor !== Object) throw new Error('\"' + e.name + '\" expects to receive an object with nested query or field level operators');\n  },\n  parse: function (e, r, o) {\n    var a = o.parse,\n        i = o.field,\n        f = (0, o.hasOperators)(r) ? a(r, {\n      field: n\n    }) : a(r);\n    return new t(e.name, i, f);\n  }\n},\n    w = {\n  type: \"field\",\n  validate: c(\"number\")\n},\n    y = {\n  type: \"field\",\n  validate: f\n},\n    $ = y,\n    x = y,\n    h = {\n  type: \"field\",\n  validate: function (e, t) {\n    if (!Array.isArray(t) || 2 !== t.length) throw new Error('\"' + e.name + '\" expects an array with 2 numeric elements');\n  }\n},\n    m = {\n  type: \"field\",\n  validate: c(\"boolean\")\n},\n    g = {\n  type: \"field\",\n  validate: function (e, t) {\n    if (!(\"string\" == typeof t || \"number\" == typeof t || t instanceof Date)) throw new Error('\"' + e.name + '\" expects value to be comparable (i.e., string, number or date)');\n  }\n},\n    b = g,\n    E = b,\n    j = b,\n    O = {\n  type: \"field\"\n},\n    R = O,\n    _ = {\n  type: \"field\",\n  validate: function (e, t) {\n    if (!(t instanceof RegExp) && \"string\" != typeof t) throw new Error('\"' + e.name + '\" expects value to be a regular expression or a string that represents regular expression');\n  },\n  parse: function (e, r, n) {\n    var o = \"string\" == typeof r ? new RegExp(r, n.query.$options || \"\") : r;\n    return new t(e.name, n.field, o);\n  }\n},\n    q = {\n  type: \"field\",\n  parse: function () {\n    return o;\n  }\n},\n    A = {\n  type: \"document\",\n  validate: c(\"function\")\n},\n    N = Object.freeze({\n  __proto__: null,\n  $and: p,\n  $or: s,\n  $nor: l,\n  $not: d,\n  $elemMatch: v,\n  $size: w,\n  $in: y,\n  $nin: $,\n  $all: x,\n  $mod: h,\n  $exists: m,\n  $gte: g,\n  $gt: b,\n  $lt: E,\n  $lte: j,\n  $eq: O,\n  $ne: R,\n  $regex: _,\n  $options: q,\n  $where: A\n});\n\nvar P = function (e) {\n  var t, r;\n\n  function n(t) {\n    return e.call(this, t, {\n      defaultOperatorName: \"$eq\",\n      operatorToConditionName: function (e) {\n        return e.slice(1);\n      }\n    }) || this;\n  }\n\n  return r = e, (t = n).prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r, n.prototype.parse = function (t, r) {\n    return r && r.field ? a(this.parseFieldOperators(r.field, t)) : e.prototype.parse.call(this, t);\n  }, n;\n}(i),\n    z = N;\n\nexport { x as $all, p as $and, v as $elemMatch, O as $eq, m as $exists, b as $gt, g as $gte, y as $in, E as $lt, j as $lte, h as $mod, R as $ne, $ as $nin, l as $nor, d as $not, q as $options, s as $or, _ as $regex, w as $size, A as $where, P as MongoQueryParser, z as allParsingInstructions };","map":null,"metadata":{},"sourceType":"module"}