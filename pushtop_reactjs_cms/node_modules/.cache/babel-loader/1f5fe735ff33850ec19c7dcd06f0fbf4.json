{"ast":null,"code":"var $8zHUo$sortablejs = require(\"sortablejs\");\n\nvar $8zHUo$classnames = require(\"classnames\");\n\nvar $8zHUo$react = require(\"react\");\n\nvar $8zHUo$tinyinvariant = require(\"tiny-invariant\");\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {\n    get: v,\n    set: s,\n    enumerable: true,\n    configurable: true\n  });\n}\n\nfunction $parcel$exportWildcard(dest, source) {\n  Object.keys(source).forEach(function (key) {\n    if (key === 'default' || key === '__esModule' || dest.hasOwnProperty(key)) {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function get() {\n        return source[key];\n      }\n    });\n  });\n  return dest;\n}\n\n$parcel$export(module.exports, \"Sortable\", () => $882b6d93070905b3$re_export$Sortable);\n$parcel$export(module.exports, \"Direction\", () => $882b6d93070905b3$re_export$Direction);\n$parcel$export(module.exports, \"DOMRect\", () => $882b6d93070905b3$re_export$DOMRect);\n$parcel$export(module.exports, \"GroupOptions\", () => $882b6d93070905b3$re_export$GroupOptions);\n$parcel$export(module.exports, \"MoveEvent\", () => $882b6d93070905b3$re_export$MoveEvent);\n$parcel$export(module.exports, \"Options\", () => $882b6d93070905b3$re_export$Options);\n$parcel$export(module.exports, \"PullResult\", () => $882b6d93070905b3$re_export$PullResult);\n$parcel$export(module.exports, \"PutResult\", () => $882b6d93070905b3$re_export$PutResult);\n$parcel$export(module.exports, \"SortableEvent\", () => $882b6d93070905b3$re_export$SortableEvent);\n$parcel$export(module.exports, \"SortableOptions\", () => $882b6d93070905b3$re_export$SortableOptions);\n$parcel$export(module.exports, \"Utils\", () => $882b6d93070905b3$re_export$Utils);\n$parcel$export(module.exports, \"ReactSortable\", () => $7fe8e3ea572bda7a$export$11bbed9ee0012c13);\n\nfunction $eb03e74f8f7db1f3$export$1d0aa160432dfea5(node) {\n  if (node.parentElement !== null) node.parentElement.removeChild(node);\n}\n\nfunction $eb03e74f8f7db1f3$export$6d240faa51aa562f(parent, newChild, index) {\n  const refChild = parent.children[index] || null;\n  parent.insertBefore(newChild, refChild);\n}\n\nfunction $eb03e74f8f7db1f3$export$d7d742816c28cf91(customs) {\n  $eb03e74f8f7db1f3$export$77f49a256021c8de(customs);\n  $eb03e74f8f7db1f3$export$a6177d5829f70ebc(customs);\n}\n\nfunction $eb03e74f8f7db1f3$export$77f49a256021c8de(customs) {\n  customs.forEach(curr => $eb03e74f8f7db1f3$export$1d0aa160432dfea5(curr.element));\n}\n\nfunction $eb03e74f8f7db1f3$export$a6177d5829f70ebc(customs) {\n  customs.forEach(curr => {\n    $eb03e74f8f7db1f3$export$6d240faa51aa562f(curr.parentElement, curr.element, curr.oldIndex);\n  });\n}\n\nfunction $eb03e74f8f7db1f3$export$4655efe700f887a(evt, list) {\n  const mode = $eb03e74f8f7db1f3$export$1fc0f6205829e19c(evt);\n  const parentElement = {\n    parentElement: evt.from\n  };\n  let custom = [];\n\n  switch (mode) {\n    case \"normal\":\n      /* eslint-disable */\n      const item = {\n        element: evt.item,\n        newIndex: evt.newIndex,\n        oldIndex: evt.oldIndex,\n        parentElement: evt.from\n      };\n      custom = [item];\n      break;\n\n    case \"swap\":\n      const drag = {\n        element: evt.item,\n        oldIndex: evt.oldIndex,\n        newIndex: evt.newIndex,\n        ...parentElement\n      };\n      const swap = {\n        element: evt.swapItem,\n        oldIndex: evt.newIndex,\n        newIndex: evt.oldIndex,\n        ...parentElement\n      };\n      custom = [drag, swap];\n      break;\n\n    case \"multidrag\":\n      custom = evt.oldIndicies.map((curr, index) => ({\n        element: curr.multiDragElement,\n        oldIndex: curr.index,\n        newIndex: evt.newIndicies[index].index,\n        ...parentElement\n      }));\n      break;\n  }\n  /* eslint-enable */\n\n\n  const customs = $eb03e74f8f7db1f3$export$bc06a3af7dc65f53(custom, list);\n  return customs;\n}\n\nfunction $eb03e74f8f7db1f3$export$c25cf8080bd305ec(normalized, list) {\n  const a = $eb03e74f8f7db1f3$export$be2da95e6167b0bd(normalized, list);\n  const b = $eb03e74f8f7db1f3$export$eca851ee65ae17e4(normalized, a);\n  return b;\n}\n\nfunction $eb03e74f8f7db1f3$export$be2da95e6167b0bd(normalized, list) {\n  const newList = [...list];\n  normalized.concat().reverse().forEach(curr => newList.splice(curr.oldIndex, 1));\n  return newList;\n}\n\nfunction $eb03e74f8f7db1f3$export$eca851ee65ae17e4(normalized, list, evt, clone) {\n  const newList = [...list];\n  normalized.forEach(curr => {\n    const newItem = clone && evt && clone(curr.item, evt);\n    newList.splice(curr.newIndex, 0, newItem || curr.item);\n  });\n  return newList;\n}\n\nfunction $eb03e74f8f7db1f3$export$1fc0f6205829e19c(evt) {\n  if (evt.oldIndicies && evt.oldIndicies.length > 0) return \"multidrag\";\n  if (evt.swapItem) return \"swap\";\n  return \"normal\";\n}\n\nfunction $eb03e74f8f7db1f3$export$bc06a3af7dc65f53(inputs, list) {\n  const normalized = inputs.map(curr => ({ ...curr,\n    item: list[curr.oldIndex]\n  })).sort((a, b) => a.oldIndex - b.oldIndex);\n  return normalized;\n}\n\nfunction $eb03e74f8f7db1f3$export$7553c81e62e31b7e(props) {\n  /* eslint-disable */\n  const {\n    list: // react sortable props\n    list,\n    setList: setList,\n    children: children,\n    tag: tag,\n    style: style,\n    className: className,\n    clone: clone,\n    onAdd: // sortable options that have methods we want to overwrite\n    onAdd,\n    onChange: onChange,\n    onChoose: onChoose,\n    onClone: onClone,\n    onEnd: onEnd,\n    onFilter: onFilter,\n    onRemove: onRemove,\n    onSort: onSort,\n    onStart: onStart,\n    onUnchoose: onUnchoose,\n    onUpdate: onUpdate,\n    onMove: onMove,\n    onSpill: onSpill,\n    onSelect: onSelect,\n    onDeselect: onDeselect,\n    ...options\n  } = props;\n  /* eslint-enable */\n\n  return options;\n}\n/** Holds a global reference for which react element is being dragged */\n// @todo - use context to manage this. How does one use 2 different providers?\n\n\nconst $7fe8e3ea572bda7a$var$store = {\n  dragging: null\n};\n\nclass $7fe8e3ea572bda7a$export$11bbed9ee0012c13 extends $8zHUo$react.Component {\n  constructor(props) {\n    super(props); // @todo forward ref this component\n\n    this.ref = /*#__PURE__*/$8zHUo$react.createRef(); // make all state false because we can't change sortable unless a mouse gesture is made.\n\n    const newList = [...props.list].map(item => Object.assign(item, {\n      chosen: false,\n      selected: false\n    }));\n    props.setList(newList, this.sortable, $7fe8e3ea572bda7a$var$store);\n    $parcel$interopDefault($8zHUo$tinyinvariant)( //@ts-expect-error: Doesn't exist. Will deprecate soon.\n    !props.plugins, `\nPlugins prop is no longer supported.\nInstead, mount it with \"Sortable.mount(new MultiDrag())\"\nPlease read the updated README.md at https://github.com/SortableJS/react-sortablejs.\n      `);\n  }\n\n  componentDidMount() {\n    if (this.ref.current === null) return;\n    const newOptions = this.makeOptions();\n    $parcel$interopDefault($8zHUo$sortablejs).create(this.ref.current, newOptions);\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.disabled !== this.props.disabled && this.sortable) this.sortable.option(\"disabled\", this.props.disabled);\n  }\n\n  render() {\n    const {\n      tag: tag,\n      style: style,\n      className: className,\n      id: id\n    } = this.props;\n    const classicProps = {\n      style: style,\n      className: className,\n      id: id\n    }; // if no tag, default to a `div` element.\n\n    const newTag = !tag || tag === null ? \"div\" : tag;\n    return /*#__PURE__*/$8zHUo$react.createElement(newTag, {\n      // @todo - find a way (perhaps with the callback) to allow AntD components to work\n      ref: this.ref,\n      ...classicProps\n    }, this.getChildren());\n  }\n\n  getChildren() {\n    const {\n      children: children,\n      dataIdAttr: dataIdAttr,\n      selectedClass = \"sortable-selected\",\n      chosenClass = \"sortable-chosen\",\n\n      /* eslint-disable */\n      dragClass = \"sortable-drag\",\n      fallbackClass = \"sortable-falback\",\n      ghostClass = \"sortable-ghost\",\n      swapClass = \"sortable-swap-highlight\",\n\n      /* eslint-enable */\n      filter = \"sortable-filter\",\n      list: list\n    } = this.props; // if no children, don't do anything.\n\n    if (!children || children == null) return null;\n    const dataid = dataIdAttr || \"data-id\";\n    /* eslint-disable-next-line */\n\n    return $8zHUo$react.Children.map(children, (child, index) => {\n      if (child === undefined) return undefined;\n      const item = list[index] || {};\n      const {\n        className: prevClassName\n      } = child.props; // @todo - handle the function if avalable. I don't think anyone will be doing this soon.\n\n      const filtered = typeof filter === \"string\" && {\n        [filter.replace(\".\", \"\")]: !!item.filtered\n      };\n      const className = $parcel$interopDefault($8zHUo$classnames)(prevClassName, {\n        [selectedClass]: item.selected,\n        [chosenClass]: item.chosen,\n        ...filtered\n      });\n      return /*#__PURE__*/$8zHUo$react.cloneElement(child, {\n        [dataid]: child.key,\n        className: className\n      });\n    });\n  }\n  /** Appends the `sortable` property to this component */\n\n\n  get sortable() {\n    const el = this.ref.current;\n    if (el === null) return null;\n    const key = Object.keys(el).find(k => k.includes(\"Sortable\"));\n    if (!key) return null; //@ts-expect-error: fix me.\n\n    return el[key];\n  }\n  /** Converts all the props from `ReactSortable` into the `options` object that `Sortable.create(el, [options])` can use. */\n\n\n  makeOptions() {\n    const DOMHandlers = [\"onAdd\", \"onChoose\", \"onDeselect\", \"onEnd\", \"onRemove\", \"onSelect\", \"onSpill\", \"onStart\", \"onUnchoose\", \"onUpdate\"];\n    const NonDOMHandlers = [\"onChange\", \"onClone\", \"onFilter\", \"onSort\"];\n    const newOptions = $eb03e74f8f7db1f3$export$7553c81e62e31b7e(this.props);\n    DOMHandlers.forEach(name => newOptions[name] = this.prepareOnHandlerPropAndDOM(name));\n    NonDOMHandlers.forEach(name => newOptions[name] = this.prepareOnHandlerProp(name));\n    /** onMove has 2 arguments and needs to be handled seperately. */\n\n    const onMove1 = (evt, originalEvt) => {\n      const {\n        onMove: onMove\n      } = this.props;\n      const defaultValue = evt.willInsertAfter || -1;\n      if (!onMove) return defaultValue;\n      const result = onMove(evt, originalEvt, this.sortable, $7fe8e3ea572bda7a$var$store);\n      if (typeof result === \"undefined\") return false;\n      return result;\n    };\n\n    return { ...newOptions,\n      onMove: onMove1\n    };\n  }\n  /** Prepares a method that will be used in the sortable options to call an `on[Handler]` prop & an `on[Handler]` ReactSortable method.  */\n\n\n  prepareOnHandlerPropAndDOM(evtName) {\n    return evt => {\n      // call the component prop\n      this.callOnHandlerProp(evt, evtName); // calls state change\n      //@ts-expect-error: until @types multidrag item is in\n\n      this[evtName](evt);\n    };\n  }\n  /** Prepares a method that will be used in the sortable options to call an `on[Handler]` prop */\n\n\n  prepareOnHandlerProp(evtName) {\n    return evt => {\n      // call the component prop\n      this.callOnHandlerProp(evt, evtName);\n    };\n  }\n  /** Calls the `props.on[Handler]` function */\n\n\n  callOnHandlerProp(evt, evtName) {\n    const propEvent = this.props[evtName];\n    if (propEvent) propEvent(evt, this.sortable, $7fe8e3ea572bda7a$var$store);\n  } // SORTABLE DOM HANDLING\n\n\n  onAdd(evt) {\n    const {\n      list: list,\n      setList: setList,\n      clone: clone\n    } = this.props;\n    /* eslint-disable-next-line */\n\n    const otherList = [...$7fe8e3ea572bda7a$var$store.dragging.props.list];\n    const customs = $eb03e74f8f7db1f3$export$4655efe700f887a(evt, otherList);\n    $eb03e74f8f7db1f3$export$77f49a256021c8de(customs);\n    const newList = $eb03e74f8f7db1f3$export$eca851ee65ae17e4(customs, list, evt, clone).map(item => Object.assign(item, {\n      selected: false\n    }));\n    setList(newList, this.sortable, $7fe8e3ea572bda7a$var$store);\n  }\n\n  onRemove(evt) {\n    const {\n      list: list,\n      setList: setList\n    } = this.props;\n    const mode = $eb03e74f8f7db1f3$export$1fc0f6205829e19c(evt);\n    const customs = $eb03e74f8f7db1f3$export$4655efe700f887a(evt, list);\n    $eb03e74f8f7db1f3$export$a6177d5829f70ebc(customs);\n    let newList = [...list]; // remove state if not in clone mode. otherwise, keep.\n\n    if (evt.pullMode !== \"clone\") newList = $eb03e74f8f7db1f3$export$be2da95e6167b0bd(customs, newList);else {\n      // switch used to get the clone\n      let customClones = customs;\n\n      switch (mode) {\n        case \"multidrag\":\n          customClones = customs.map((item, index) => ({ ...item,\n            element: evt.clones[index]\n          }));\n          break;\n\n        case \"normal\":\n          customClones = customs.map(item => ({ ...item,\n            element: evt.clone\n          }));\n          break;\n\n        case \"swap\":\n        default:\n          $parcel$interopDefault($8zHUo$tinyinvariant)(true, `mode \"${mode}\" cannot clone. Please remove \"props.clone\" from <ReactSortable/> when using the \"${mode}\" plugin`);\n      }\n\n      $eb03e74f8f7db1f3$export$77f49a256021c8de(customClones); // replace selected items with cloned items\n\n      customs.forEach(curr => {\n        const index = curr.oldIndex;\n        /* eslint-disable-next-line */\n\n        const newItem = this.props.clone(curr.item, evt);\n        newList.splice(index, 1, newItem);\n      });\n    } // remove item.selected from list\n\n    newList = newList.map(item => Object.assign(item, {\n      selected: false\n    }));\n    setList(newList, this.sortable, $7fe8e3ea572bda7a$var$store);\n  }\n\n  onUpdate(evt) {\n    const {\n      list: list,\n      setList: setList\n    } = this.props;\n    const customs = $eb03e74f8f7db1f3$export$4655efe700f887a(evt, list);\n    $eb03e74f8f7db1f3$export$77f49a256021c8de(customs);\n    $eb03e74f8f7db1f3$export$a6177d5829f70ebc(customs);\n    const newList = $eb03e74f8f7db1f3$export$c25cf8080bd305ec(customs, list);\n    return setList(newList, this.sortable, $7fe8e3ea572bda7a$var$store);\n  }\n\n  onStart() {\n    $7fe8e3ea572bda7a$var$store.dragging = this;\n  }\n\n  onEnd() {\n    $7fe8e3ea572bda7a$var$store.dragging = null;\n  }\n\n  onChoose(evt) {\n    const {\n      list: list,\n      setList: setList\n    } = this.props;\n    const newList = list.map((item, index) => {\n      let newItem = item;\n      if (index === evt.oldIndex) newItem = Object.assign(item, {\n        chosen: true\n      });\n      return newItem;\n    });\n    setList(newList, this.sortable, $7fe8e3ea572bda7a$var$store);\n  }\n\n  onUnchoose(evt) {\n    const {\n      list: list,\n      setList: setList\n    } = this.props;\n    const newList = list.map((item, index) => {\n      let newItem = item;\n      if (index === evt.oldIndex) newItem = Object.assign(newItem, {\n        chosen: false\n      });\n      return newItem;\n    });\n    setList(newList, this.sortable, $7fe8e3ea572bda7a$var$store);\n  }\n\n  onSpill(evt) {\n    const {\n      removeOnSpill: removeOnSpill,\n      revertOnSpill: revertOnSpill\n    } = this.props;\n    if (removeOnSpill && !revertOnSpill) $eb03e74f8f7db1f3$export$1d0aa160432dfea5(evt.item);\n  }\n\n  onSelect(evt) {\n    const {\n      list: list,\n      setList: setList\n    } = this.props;\n    const newList = list.map(item => Object.assign(item, {\n      selected: false\n    }));\n    evt.newIndicies.forEach(curr => {\n      const index = curr.index;\n\n      if (index === -1) {\n        console.log(`\"${evt.type}\" had indice of \"${curr.index}\", which is probably -1 and doesn't usually happen here.`);\n        console.log(evt);\n        return;\n      }\n\n      newList[index].selected = true;\n    });\n    setList(newList, this.sortable, $7fe8e3ea572bda7a$var$store);\n  }\n\n  onDeselect(evt) {\n    const {\n      list: list,\n      setList: setList\n    } = this.props;\n    const newList = list.map(item => Object.assign(item, {\n      selected: false\n    }));\n    evt.newIndicies.forEach(curr => {\n      const index = curr.index;\n      if (index === -1) return;\n      newList[index].selected = true;\n    });\n    setList(newList, this.sortable, $7fe8e3ea572bda7a$var$store);\n  }\n\n}\n\n$7fe8e3ea572bda7a$export$11bbed9ee0012c13.defaultProps = {\n  clone: item => item\n};\nvar $faefaad95e5fcca0$exports = {};\n$parcel$exportWildcard(module.exports, $faefaad95e5fcca0$exports);","map":null,"metadata":{},"sourceType":"script"}