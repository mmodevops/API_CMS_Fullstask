{"ast":null,"code":"import t, { Fragment as n, createElement as r, Children as i, PureComponent as u } from \"react\";\n\nfunction e(t, n) {\n  for (var r = 0; r < n.length; r++) {\n    var i = n[r];\n    i.enumerable = i.enumerable || false;\n    i.configurable = true;\n    if (\"value\" in i) i.writable = true;\n    Object.defineProperty(t, i.key, i);\n  }\n}\n\nfunction o(t, n, r) {\n  if (n) e(t.prototype, n);\n  if (r) e(t, r);\n  return t;\n}\n\nfunction f() {\n  f = Object.assign || function (t) {\n    for (var n = 1; n < arguments.length; n++) {\n      var r = arguments[n];\n\n      for (var i in r) if (Object.prototype.hasOwnProperty.call(r, i)) t[i] = r[i];\n    }\n\n    return t;\n  };\n\n  return f.apply(this, arguments);\n}\n\nfunction c(t, n) {\n  t.prototype = Object.create(n.prototype);\n  t.prototype.constructor = t;\n  a(t, n);\n}\n\nfunction a(t, n) {\n  a = Object.setPrototypeOf || function t(n, r) {\n    n.__proto__ = r;\n    return n;\n  };\n\n  return a(t, n);\n}\n\nvar s = function t() {};\n\nvar h = n ? function (t) {\n  if (!t) return null;\n  return t.length > 1 ? r.apply(void 0, [n, null].concat(t)) : i.only(t);\n} : i.only;\n\nvar l = function (t) {\n  c(n, t);\n\n  function n() {\n    var n;\n\n    for (var r = arguments.length, i = new Array(r), u = 0; u < r; u++) i[u] = arguments[u];\n\n    n = t.call.apply(t, [this].concat(i)) || this;\n    n.t = false;\n    n.i = null;\n    n.u = s;\n    return n;\n  }\n\n  var r = n.prototype;\n\n  r.componentWillUnmount = function t() {\n    this.u();\n  };\n\n  r.o = function _connectToAbility(t) {\n    var n = this;\n    if (t === this.i) return;\n    this.u();\n    this.i = null;\n\n    if (t) {\n      this.i = t;\n      this.u = t.on(\"updated\", function () {\n        return n.forceUpdate();\n      });\n    }\n  };\n\n  r.h = function t() {\n    var n = this.props;\n    var r = n.of || n.a || n.an || n.this || n.on;\n    var i = n.not ? \"cannot\" : \"can\";\n    return n.ability[i](n.I || n.do, r, n.field);\n  };\n\n  r.render = function t() {\n    this.o(this.props.ability);\n    this.t = this.h();\n    return this.props.passThrough || this.t ? this.l() : null;\n  };\n\n  r.l = function t() {\n    var n = this.props,\n        r = n.children,\n        i = n.ability;\n    var u = \"function\" === typeof r ? r(this.t, i) : r;\n    return h(u);\n  };\n\n  o(n, [{\n    key: \"allowed\",\n    get: function t() {\n      return this.t;\n    }\n  }]);\n  return n;\n}(u);\n\nfunction v(t) {\n  var n, r;\n  return r = n = function (t) {\n    c(n, t);\n\n    function n() {\n      return t.apply(this, arguments) || this;\n    }\n\n    return n;\n  }(l), n.defaultProps = {\n    ability: t\n  }, r;\n}\n\nfunction b(t) {\n  return function (n) {\n    return r(t, null, function (t) {\n      return r(l, f({\n        ability: t\n      }, n));\n    });\n  };\n}\n\nfunction useAbility(n) {\n  if (\"production\" !== process.env.NODE_ENV && \"function\" !== typeof t.useContext) throw new Error(\"You must use React >= 16.8 in order to use useAbility()\");\n  var r = t.useContext(n);\n  var i = t.useState(),\n      u = i[0],\n      e = i[1];\n  t.useEffect(function () {\n    return r.on(\"updated\", function (t) {\n      if (t.rules !== u) e(t.rules);\n    });\n  }, []);\n  return r;\n}\n\nexport { l as Can, v as createCanBoundTo, b as createContextualCan, useAbility };","map":null,"metadata":{},"sourceType":"module"}