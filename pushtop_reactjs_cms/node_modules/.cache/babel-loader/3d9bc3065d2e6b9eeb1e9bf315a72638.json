{"ast":null,"code":"function t(t, r) {\n  for (var n = 0; n < r.length; n++) {\n    var i = r[n];\n    i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);\n  }\n}\n\nfunction r() {\n  return (r = Object.assign || function (t) {\n    for (var r = 1; r < arguments.length; r++) {\n      var n = arguments[r];\n\n      for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);\n    }\n\n    return t;\n  }).apply(this, arguments);\n}\n\nfunction n(t, r) {\n  t.prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r;\n}\n\nvar i = function () {\n  function r(t, r) {\n    this.operator = t, this.value = r, Object.defineProperty(this, \"t\", {\n      writable: !0\n    });\n  }\n\n  var n, i, e;\n  return r.prototype.addNote = function (t) {\n    this.t = this.t || [], this.t.push(t);\n  }, n = r, (i = [{\n    key: \"notes\",\n    get: function () {\n      return this.t;\n    }\n  }]) && t(n.prototype, i), e && t(n, e), r;\n}(),\n    e = function (t) {\n  function r() {\n    return t.apply(this, arguments) || this;\n  }\n\n  return n(r, t), r;\n}(i),\n    o = function (t) {\n  function r(r, n) {\n    if (!Array.isArray(n)) throw new Error('\"' + r + '\" operator expects to receive an array of conditions');\n    return t.call(this, r, n) || this;\n  }\n\n  return n(r, t), r;\n}(e),\n    u = \"__itself__\",\n    f = function (t) {\n  function r(r, n, i) {\n    var e;\n    return (e = t.call(this, r, i) || this).field = n, e;\n  }\n\n  return n(r, t), r;\n}(i),\n    a = new e(\"__null__\", null),\n    c = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);\n\nfunction s(t, r) {\n  return r instanceof o && r.operator === t;\n}\n\nfunction h(t, r) {\n  return 1 === r.length ? r[0] : new o(t, function t(r, n, i) {\n    for (var e = i || [], o = 0, u = n.length; o < u; o++) {\n      var f = n[o];\n      s(r, f) ? t(r, f.value, e) : e.push(f);\n    }\n\n    return e;\n  }(t, r));\n}\n\nvar v = function (t) {\n  return t;\n},\n    d = function () {\n  return Object.create(null);\n},\n    l = Object.defineProperty(d(), \"__@type@__\", {\n  value: \"ignore value\"\n});\n\nfunction p(t, r, n) {\n  if (void 0 === n && (n = !1), !t || t && t.constructor !== Object) return !1;\n\n  for (var i in t) {\n    if (c(t, i) && c(r, i) && (!n || t[i] !== l)) return !0;\n  }\n\n  return !1;\n}\n\nfunction w(t) {\n  var r = [];\n\n  for (var n in t) c(t, n) && t[n] !== l && r.push(n);\n\n  return r;\n}\n\nfunction b(t, r) {\n  r !== a && t.push(r);\n}\n\nvar y = function (t) {\n  return h(\"and\", t);\n},\n    O = function (t) {\n  return h(\"or\", t);\n},\n    j = {\n  compound: function (t, r, n) {\n    var i = (Array.isArray(r) ? r : [r]).map(function (t) {\n      return n.parse(t);\n    });\n    return new o(t.name, i);\n  },\n  field: function (t, r, n) {\n    return new f(t.name, n.field, r);\n  },\n  document: function (t, r) {\n    return new e(t.name, r);\n  }\n},\n    _ = function () {\n  function t(t, n) {\n    var i = this;\n    void 0 === n && (n = d()), this.i = void 0, this.o = void 0, this.u = void 0, this.s = void 0, this.h = void 0, this.parse = this.parse.bind(this), this.s = {\n      operatorToConditionName: n.operatorToConditionName || v,\n      defaultOperatorName: n.defaultOperatorName || \"eq\",\n      mergeFinalConditions: n.mergeFinalConditions || y\n    }, this.i = Object.keys(t).reduce(function (n, e) {\n      return n[e] = r({\n        name: i.s.operatorToConditionName(e)\n      }, t[e]), n;\n    }, {}), this.o = r({}, n.fieldContext, {\n      field: \"\",\n      query: {},\n      parse: this.parse,\n      hasOperators: function (t) {\n        return p(t, i.i, n.useIgnoreValue);\n      }\n    }), this.u = r({}, n.documentContext, {\n      parse: this.parse,\n      query: {}\n    }), this.h = n.useIgnoreValue ? w : Object.keys;\n  }\n\n  var n = t.prototype;\n  return n.setParse = function (t) {\n    this.parse = t, this.o.parse = t, this.u.parse = t;\n  }, n.parseField = function (t, r, n, i) {\n    var e = this.i[r];\n    if (!e) throw new Error('Unsupported operator \"' + r + '\"');\n    if (\"field\" !== e.type) throw new Error(\"Unexpected \" + e.type + ' operator \"' + r + '\" at field level');\n    return this.o.field = t, this.o.query = i, this.parseInstruction(e, n, this.o);\n  }, n.parseInstruction = function (t, r, n) {\n    return \"function\" == typeof t.validate && t.validate(t, r), (t.parse || j[t.type])(t, r, n);\n  }, n.parseFieldOperators = function (t, r) {\n    for (var n = [], i = this.h(r), e = 0, o = i.length; e < o; e++) {\n      var u = i[e];\n      if (!this.i[u]) throw new Error('Field query for \"' + t + '\" may contain only operators or a plain object as a value');\n      b(n, this.parseField(t, u, r[u], r));\n    }\n\n    return n;\n  }, n.parse = function (t) {\n    var r = [],\n        n = this.h(t);\n    this.u.query = t;\n\n    for (var i = 0, e = n.length; i < e; i++) {\n      var o = n[i],\n          u = t[o],\n          f = this.i[o];\n\n      if (f) {\n        if (\"document\" !== f.type && \"compound\" !== f.type) throw new Error('Cannot use parsing instruction for operator \"' + o + '\" in \"document\" context as it is supposed to be used in  \"' + f.type + '\" context');\n        b(r, this.parseInstruction(f, u, this.u));\n      } else this.o.hasOperators(u) ? r.push.apply(r, this.parseFieldOperators(o, u)) : b(r, this.parseField(o, this.s.defaultOperatorName, u, t));\n    }\n\n    return this.s.mergeFinalConditions(r);\n  }, t;\n}();\n\nfunction m(t, r) {\n  var n = t[r];\n  if (\"function\" != typeof n) throw new Error('Unable to interpret \"' + r + '\" condition. Did you forget to register interpreter for it?');\n  return n;\n}\n\nfunction g(t) {\n  return t.operator;\n}\n\nfunction E(t, n) {\n  var i,\n      e = n,\n      o = e && e.getInterpreterName || g;\n\n  switch (e ? e.numberOfArguments : 0) {\n    case 1:\n      i = function (r) {\n        var n = o(r, e);\n        return m(t, n)(r, u);\n      };\n\n      break;\n\n    case 3:\n      i = function (r, n, i) {\n        var f = o(r, e);\n        return m(t, f)(r, n, i, u);\n      };\n\n      break;\n\n    default:\n      i = function (r, n) {\n        var i = o(r, e);\n        return m(t, i)(r, n, u);\n      };\n\n  }\n\n  var u = r({}, e, {\n    interpret: i\n  });\n  return u.interpret;\n}\n\nfunction x(t, r) {\n  return function (n) {\n    for (var i = arguments.length, e = new Array(i > 1 ? i - 1 : 0), o = 1; o < i; o++) e[o - 1] = arguments[o];\n\n    var u = t.apply(void 0, [n].concat(e)),\n        f = r.bind(null, u);\n    return f.ast = u, f;\n  };\n}\n\nvar q = _.prototype.parseInstruction;\nexport { o as CompoundCondition, i as Condition, e as DocumentCondition, f as FieldCondition, u as ITSELF, a as NULL_CONDITION, _ as ObjectQueryParser, y as buildAnd, O as buildOr, E as createInterpreter, x as createTranslatorFactory, j as defaultInstructionParsers, p as hasOperators, v as identity, l as ignoreValue, s as isCompound, d as object, h as optimizedCompoundCondition, q as parseInstruction };","map":null,"metadata":{},"sourceType":"module"}