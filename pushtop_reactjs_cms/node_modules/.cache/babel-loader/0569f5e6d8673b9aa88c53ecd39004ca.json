{"ast":null,"code":"import { createTranslatorFactory as r, ITSELF as t } from \"@ucast/core\";\nexport * from \"@ucast/core\";\nimport { MongoQueryParser as o, allParsingInstructions as n, defaultParsers as e } from \"@ucast/mongo\";\nexport * from \"@ucast/mongo\";\nimport { createJsInterpreter as f, allInterpreters as i, compare as u } from \"@ucast/js\";\nexport * from \"@ucast/js\";\n\nfunction c() {\n  return (c = Object.assign || function (r) {\n    for (var t = 1; t < arguments.length; t++) {\n      var o = arguments[t];\n\n      for (var n in o) Object.prototype.hasOwnProperty.call(o, n) && (r[n] = o[n]);\n    }\n\n    return r;\n  }).apply(this, arguments);\n}\n\nfunction a(r) {\n  return r instanceof Date ? r.getTime() : r && \"function\" == typeof r.toJSON ? r.toJSON() : r;\n}\n\nvar m = function (r, t) {\n  return u(a(r), a(t));\n};\n\nfunction p(n, e, i) {\n  var u = new o(n),\n      a = f(e, c({\n    compare: m\n  }, i));\n\n  if (i && i.forPrimitives) {\n    var p = {\n      field: t\n    },\n        s = u.parse;\n    u.setParse(function (r) {\n      return s(r, p);\n    });\n  }\n\n  return r(u.parse, a);\n}\n\nvar s = p(n, i),\n    v = p([\"$and\", \"$or\"].reduce(function (r, t) {\n  return r[t] = c({}, r[t], {\n    type: \"field\"\n  }), r;\n}, c({}, n, {\n  $nor: c({}, n.$nor, {\n    type: \"field\",\n    parse: e.compound\n  })\n})), i, {\n  forPrimitives: !0\n}),\n    d = s;\nexport { p as createFactory, d as filter, s as guard, v as squire };","map":null,"metadata":{},"sourceType":"module"}